// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "3")]
    pub schema_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "schema::Type", required, tag = "4")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "5")]
    pub properties: ::prost::alloc::vec::Vec<KeyValue>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        None = 0,
        String = 1,
        Json = 2,
        Protobuf = 3,
        Avro = 4,
        Bool = 5,
        Int8 = 6,
        Int16 = 7,
        Int32 = 8,
        Int64 = 9,
        Float = 10,
        Double = 11,
        Date = 12,
        Time = 13,
        Timestamp = 14,
        KeyValue = 15,
        Instant = 16,
        LocalDate = 17,
        LocalTime = 18,
        LocalDateTime = 19,
        ProtobufNative = 20,
        AutoConsume = 21,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::None => "None",
                Type::String => "String",
                Type::Json => "Json",
                Type::Protobuf => "Protobuf",
                Type::Avro => "Avro",
                Type::Bool => "Bool",
                Type::Int8 => "Int8",
                Type::Int16 => "Int16",
                Type::Int32 => "Int32",
                Type::Int64 => "Int64",
                Type::Float => "Float",
                Type::Double => "Double",
                Type::Date => "Date",
                Type::Time => "Time",
                Type::Timestamp => "Timestamp",
                Type::KeyValue => "KeyValue",
                Type::Instant => "Instant",
                Type::LocalDate => "LocalDate",
                Type::LocalTime => "LocalTime",
                Type::LocalDateTime => "LocalDateTime",
                Type::ProtobufNative => "ProtobufNative",
                Type::AutoConsume => "AutoConsume",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "None" => Some(Self::None),
                "String" => Some(Self::String),
                "Json" => Some(Self::Json),
                "Protobuf" => Some(Self::Protobuf),
                "Avro" => Some(Self::Avro),
                "Bool" => Some(Self::Bool),
                "Int8" => Some(Self::Int8),
                "Int16" => Some(Self::Int16),
                "Int32" => Some(Self::Int32),
                "Int64" => Some(Self::Int64),
                "Float" => Some(Self::Float),
                "Double" => Some(Self::Double),
                "Date" => Some(Self::Date),
                "Time" => Some(Self::Time),
                "Timestamp" => Some(Self::Timestamp),
                "KeyValue" => Some(Self::KeyValue),
                "Instant" => Some(Self::Instant),
                "LocalDate" => Some(Self::LocalDate),
                "LocalTime" => Some(Self::LocalTime),
                "LocalDateTime" => Some(Self::LocalDateTime),
                "ProtobufNative" => Some(Self::ProtobufNative),
                "AutoConsume" => Some(Self::AutoConsume),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageIdData {
    #[prost(uint64, required, tag = "1")]
    pub ledger_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub entry_id: u64,
    #[prost(int32, optional, tag = "3", default = "-1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub batch_index: ::core::option::Option<i32>,
    #[prost(int64, repeated, packed = "false", tag = "5")]
    pub ack_set: ::prost::alloc::vec::Vec<i64>,
    #[prost(int32, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub batch_size: ::core::option::Option<i32>,
    /// For the chunk message id, we need to specify the first chunk message id.
    #[prost(message, optional, boxed, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_chunk_message_id: ::core::option::Option<
        ::prost::alloc::boxed::Box<MessageIdData>,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValue {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyLongValue {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "2")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntRange {
    #[prost(int32, required, tag = "1")]
    pub start: i32,
    #[prost(int32, required, tag = "2")]
    pub end: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionKeys {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub metadata: ::prost::alloc::vec::Vec<KeyValue>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageMetadata {
    #[prost(string, required, tag = "1")]
    pub producer_name: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "2")]
    pub sequence_id: u64,
    #[prost(uint64, required, tag = "3")]
    pub publish_time: u64,
    #[prost(message, repeated, tag = "4")]
    pub properties: ::prost::alloc::vec::Vec<KeyValue>,
    /// Property set on replicated message,
    /// includes the source cluster name
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replicated_from: ::core::option::Option<::prost::alloc::string::String>,
    /// key to decide partition for the msg
    #[prost(string, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Override namespace's replication
    #[prost(string, repeated, tag = "7")]
    pub replicate_to: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "CompressionType", optional, tag = "8", default = "None")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compression: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uncompressed_size: ::core::option::Option<u32>,
    /// Removed below checksum field from Metadata as
    /// it should be part of send-command which keeps checksum of header + payload
    /// optional sfixed64 checksum = 10;
    /// differentiate single and batch message metadata
    #[prost(int32, optional, tag = "11", default = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub num_messages_in_batch: ::core::option::Option<i32>,
    /// the timestamp that this event occurs. it is typically set by applications.
    /// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
    #[prost(uint64, optional, tag = "12", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_time: ::core::option::Option<u64>,
    /// Contains encryption key name, encrypted key and metadata to describe the key
    #[prost(message, repeated, tag = "13")]
    pub encryption_keys: ::prost::alloc::vec::Vec<EncryptionKeys>,
    /// Algorithm used to encrypt data key
    #[prost(string, optional, tag = "14")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption_algo: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional parameters required by encryption
    #[prost(bytes = "vec", optional, tag = "15")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption_param: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "16")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "17", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key_b64_encoded: ::core::option::Option<bool>,
    /// Specific a key to overwrite the message key which used for ordering dispatch in Key_Shared mode.
    #[prost(bytes = "vec", optional, tag = "18")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ordering_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Mark the message to be delivered at or after the specified timestamp
    #[prost(int64, optional, tag = "19")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deliver_at_time: ::core::option::Option<i64>,
    /// Identify whether a message is a "marker" message used for
    /// internal metadata instead of application published data.
    /// Markers will generally not be propagated back to clients
    #[prost(int32, optional, tag = "20")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker_type: ::core::option::Option<i32>,
    /// transaction related message info
    #[prost(uint64, optional, tag = "22")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "23")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    /// / Add highest sequence id to support batch message with external sequence id
    #[prost(uint64, optional, tag = "24", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub highest_sequence_id: ::core::option::Option<u64>,
    /// Indicate if the message payload value is set
    #[prost(bool, optional, tag = "25", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub null_value: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "26")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uuid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "27")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub num_chunks_from_msg: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "28")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_chunk_msg_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "29")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chunk_id: ::core::option::Option<i32>,
    /// Indicate if the message partition key is set
    #[prost(bool, optional, tag = "30", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub null_partition_key: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleMessageMetadata {
    #[prost(message, repeated, tag = "1")]
    pub properties: ::prost::alloc::vec::Vec<KeyValue>,
    #[prost(string, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, required, tag = "3")]
    pub payload_size: i32,
    #[prost(bool, optional, tag = "4", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compacted_out: ::core::option::Option<bool>,
    /// the timestamp that this event occurs. it is typically set by applications.
    /// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
    #[prost(uint64, optional, tag = "5", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_time: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "6", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key_b64_encoded: ::core::option::Option<bool>,
    /// Specific a key to overwrite the message key which used for ordering dispatch in Key_Shared mode.
    #[prost(bytes = "vec", optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ordering_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Allows consumer retrieve the sequence id that the producer set.
    #[prost(uint64, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sequence_id: ::core::option::Option<u64>,
    /// Indicate if the message payload value is set
    #[prost(bool, optional, tag = "9", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub null_value: ::core::option::Option<bool>,
    /// Indicate if the message partition key is set
    #[prost(bool, optional, tag = "10", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub null_partition_key: ::core::option::Option<bool>,
}
/// metadata added for entry from broker
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrokerEntryMetadata {
    #[prost(uint64, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub broker_timestamp: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandConnect {
    /// The version of the client. Proxy should forward client's client_version.
    #[prost(string, required, tag = "1")]
    pub client_version: ::prost::alloc::string::String,
    /// Deprecated. Use "auth_method_name" instead.
    #[prost(enumeration = "AuthMethod", optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_method: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_method_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "4", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol_version: ::core::option::Option<i32>,
    /// Client can ask to be proxyied to a specific broker
    /// This is only honored by a Pulsar proxy
    #[prost(string, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_to_broker_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Original principal that was verified by
    /// a Pulsar proxy. In this case the auth info above
    /// will be the auth of the proxy itself
    #[prost(string, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_principal: ::core::option::Option<::prost::alloc::string::String>,
    /// Original auth role and auth Method that was passed
    /// to the proxy. In this case the auth info above
    /// will be the auth of the proxy itself
    #[prost(string, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_auth_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_auth_method: ::core::option::Option<::prost::alloc::string::String>,
    /// Feature flags
    #[prost(message, optional, tag = "10")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub feature_flags: ::core::option::Option<FeatureFlags>,
    /// Version of the proxy. Should only be forwarded by a proxy.
    #[prost(string, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_version: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureFlags {
    #[prost(bool, optional, tag = "1", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supports_auth_refresh: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supports_broker_entry_metadata: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supports_partial_producer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supports_topic_watchers: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandConnected {
    #[prost(string, required, tag = "1")]
    pub server_version: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_message_size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub feature_flags: ::core::option::Option<FeatureFlags>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAuthResponse {
    /// The version of the client. Proxy should forward client's client_version.
    #[prost(string, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: ::core::option::Option<AuthData>,
    #[prost(int32, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol_version: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAuthChallenge {
    #[prost(string, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub challenge: ::core::option::Option<AuthData>,
    #[prost(int32, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol_version: ::core::option::Option<i32>,
}
/// To support mutual authentication type, such as Sasl, reuse this command to mutual auth.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthData {
    #[prost(string, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_method_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeySharedMeta {
    #[prost(enumeration = "KeySharedMode", required, tag = "1")]
    pub key_shared_mode: i32,
    #[prost(message, repeated, tag = "3")]
    pub hash_ranges: ::prost::alloc::vec::Vec<IntRange>,
    #[prost(bool, optional, tag = "4", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_out_of_order_delivery: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSubscribe {
    #[prost(string, required, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(enumeration = "command_subscribe::SubType", required, tag = "3")]
    pub sub_type: i32,
    #[prost(uint64, required, tag = "4")]
    pub consumer_id: u64,
    #[prost(uint64, required, tag = "5")]
    pub request_id: u64,
    #[prost(string, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_level: ::core::option::Option<i32>,
    /// Signal wether the subscription should be backed by a
    /// durable cursor or not
    #[prost(bool, optional, tag = "8", default = "true")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub durable: ::core::option::Option<bool>,
    /// If specified, the subscription will position the cursor
    /// markd-delete position  on the particular message id and
    /// will send messages from that point
    #[prost(message, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_message_id: ::core::option::Option<MessageIdData>,
    /// / Add optional metadata key=value to this consumer
    #[prost(message, repeated, tag = "10")]
    pub metadata: ::prost::alloc::vec::Vec<KeyValue>,
    #[prost(bool, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub read_compacted: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "12")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: ::core::option::Option<Schema>,
    /// Signal whether the subscription will initialize on latest
    /// or not -- earliest
    #[prost(
        enumeration = "command_subscribe::InitialPosition",
        optional,
        tag = "13",
        default = "Latest"
    )]
    pub initial_position: ::core::option::Option<i32>,
    /// Mark the subscription as "replicated". Pulsar will make sure
    /// to periodically sync the state of replicated subscriptions
    /// across different clusters (when using geo-replication).
    #[prost(bool, optional, tag = "14")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replicate_subscription_state: ::core::option::Option<bool>,
    /// If true, the subscribe operation will cause a topic to be
    /// created if it does not exist already (and if topic auto-creation
    /// is allowed by broker.
    /// If false, the subscribe operation will fail if the topic
    /// does not exist.
    #[prost(bool, optional, tag = "15", default = "true")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_topic_creation: ::core::option::Option<bool>,
    /// If specified, the subscription will reset cursor's position back
    /// to specified seconds and  will send messages from that point
    #[prost(uint64, optional, tag = "16", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_message_rollback_duration_sec: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "17")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_shared_meta: ::core::option::Option<KeySharedMeta>,
    #[prost(message, repeated, tag = "18")]
    pub subscription_properties: ::prost::alloc::vec::Vec<KeyValue>,
    /// The consumer epoch, when exclusive and failover consumer redeliver unack message will increase the epoch
    #[prost(uint64, optional, tag = "19")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_epoch: ::core::option::Option<u64>,
}
/// Nested message and enum types in `CommandSubscribe`.
pub mod command_subscribe {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SubType {
        Exclusive = 0,
        Shared = 1,
        Failover = 2,
        KeyShared = 3,
    }
    impl SubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SubType::Exclusive => "Exclusive",
                SubType::Shared => "Shared",
                SubType::Failover => "Failover",
                SubType::KeyShared => "Key_Shared",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Exclusive" => Some(Self::Exclusive),
                "Shared" => Some(Self::Shared),
                "Failover" => Some(Self::Failover),
                "Key_Shared" => Some(Self::KeyShared),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InitialPosition {
        Latest = 0,
        Earliest = 1,
    }
    impl InitialPosition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InitialPosition::Latest => "Latest",
                InitialPosition::Earliest => "Earliest",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Latest" => Some(Self::Latest),
                "Earliest" => Some(Self::Earliest),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandPartitionedTopicMetadata {
    #[prost(string, required, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    /// TODO - Remove original_principal, original_auth_data, original_auth_method
    /// Original principal that was verified by
    /// a Pulsar proxy.
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_principal: ::core::option::Option<::prost::alloc::string::String>,
    /// Original auth role and auth Method that was passed
    /// to the proxy.
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_auth_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_auth_method: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandPartitionedTopicMetadataResponse {
    /// Optional in case of error
    #[prost(uint32, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partitions: ::core::option::Option<u32>,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(
        enumeration = "command_partitioned_topic_metadata_response::LookupType",
        optional,
        tag = "3"
    )]
    pub response: ::core::option::Option<i32>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CommandPartitionedTopicMetadataResponse`.
pub mod command_partitioned_topic_metadata_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LookupType {
        Success = 0,
        Failed = 1,
    }
    impl LookupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LookupType::Success => "Success",
                LookupType::Failed => "Failed",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Success" => Some(Self::Success),
                "Failed" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandLookupTopic {
    #[prost(string, required, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(bool, optional, tag = "3", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authoritative: ::core::option::Option<bool>,
    /// TODO - Remove original_principal, original_auth_data, original_auth_method
    /// Original principal that was verified by
    /// a Pulsar proxy.
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_principal: ::core::option::Option<::prost::alloc::string::String>,
    /// Original auth role and auth Method that was passed
    /// to the proxy.
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_auth_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_auth_method: ::core::option::Option<::prost::alloc::string::String>,
    ///
    #[prost(string, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub advertised_listener_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandLookupTopicResponse {
    /// Optional in case of error
    #[prost(string, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub broker_service_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub broker_service_url_tls: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "command_lookup_topic_response::LookupType",
        optional,
        tag = "3"
    )]
    pub response: ::core::option::Option<i32>,
    #[prost(uint64, required, tag = "4")]
    pub request_id: u64,
    #[prost(bool, optional, tag = "5", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authoritative: ::core::option::Option<bool>,
    #[prost(enumeration = "ServerError", optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// If it's true, indicates to the client that it must
    /// always connect through the service url after the
    /// lookup has been completed.
    #[prost(bool, optional, tag = "8", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_through_service_url: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CommandLookupTopicResponse`.
pub mod command_lookup_topic_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LookupType {
        Redirect = 0,
        Connect = 1,
        Failed = 2,
    }
    impl LookupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LookupType::Redirect => "Redirect",
                LookupType::Connect => "Connect",
                LookupType::Failed => "Failed",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Redirect" => Some(Self::Redirect),
                "Connect" => Some(Self::Connect),
                "Failed" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// / Create a new Producer on a topic, assigning the given producer_id,
/// / all messages sent with this producer_id will be persisted on the topic
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandProducer {
    #[prost(string, required, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "2")]
    pub producer_id: u64,
    #[prost(uint64, required, tag = "3")]
    pub request_id: u64,
    /// / If a producer name is specified, the name will be used,
    /// / otherwise the broker will generate a unique name
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub producer_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted: ::core::option::Option<bool>,
    /// / Add optional metadata key=value to this producer
    #[prost(message, repeated, tag = "6")]
    pub metadata: ::prost::alloc::vec::Vec<KeyValue>,
    #[prost(message, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: ::core::option::Option<Schema>,
    /// If producer reconnect to broker, the epoch of this producer will +1
    #[prost(uint64, optional, tag = "8", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub epoch: ::core::option::Option<u64>,
    /// Indicate the name of the producer is generated or user provided
    /// Use default true here is in order to be forward compatible with the client
    #[prost(bool, optional, tag = "9", default = "true")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_provided_producer_name: ::core::option::Option<bool>,
    /// Require that this producers will be the only producer allowed on the topic
    #[prost(
        enumeration = "ProducerAccessMode",
        optional,
        tag = "10",
        default = "Shared"
    )]
    pub producer_access_mode: ::core::option::Option<i32>,
    /// Topic epoch is used to fence off producers that reconnects after a new
    /// exclusive producer has already taken over. This id is assigned by the
    /// broker on the CommandProducerSuccess. The first time, the client will
    /// leave it empty and then it will always carry the same epoch number on
    /// the subsequent reconnections.
    #[prost(uint64, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_epoch: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "12", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txn_enabled: ::core::option::Option<bool>,
    /// Name of the initial subscription of the topic.
    /// If this field is not set, the initial subscription will not be created.
    /// If this field is set but the broker's `allowAutoSubscriptionCreation`
    /// is disabled, the producer will fail to be created.
    #[prost(string, optional, tag = "13")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub initial_subscription_name: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSend {
    #[prost(uint64, required, tag = "1")]
    pub producer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub sequence_id: u64,
    #[prost(int32, optional, tag = "3", default = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub num_messages: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    /// / Add highest sequence id to support batch message with external sequence id
    #[prost(uint64, optional, tag = "6", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub highest_sequence_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "7", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_chunk: ::core::option::Option<bool>,
    /// Specify if the message being published is a Pulsar marker or not
    #[prost(bool, optional, tag = "8", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: ::core::option::Option<bool>,
    /// Message id of this message, currently is used in replicator for shadow topic.
    #[prost(message, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: ::core::option::Option<MessageIdData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSendReceipt {
    #[prost(uint64, required, tag = "1")]
    pub producer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub sequence_id: u64,
    #[prost(message, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: ::core::option::Option<MessageIdData>,
    #[prost(uint64, optional, tag = "4", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub highest_sequence_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSendError {
    #[prost(uint64, required, tag = "1")]
    pub producer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub sequence_id: u64,
    #[prost(enumeration = "ServerError", required, tag = "3")]
    pub error: i32,
    #[prost(string, required, tag = "4")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandMessage {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(message, required, tag = "2")]
    pub message_id: MessageIdData,
    #[prost(uint32, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redelivery_count: ::core::option::Option<u32>,
    #[prost(int64, repeated, packed = "false", tag = "4")]
    pub ack_set: ::prost::alloc::vec::Vec<i64>,
    #[prost(uint64, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_epoch: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAck {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(enumeration = "command_ack::AckType", required, tag = "2")]
    pub ack_type: i32,
    /// In case of individual acks, the client can pass a list of message ids
    #[prost(message, repeated, tag = "3")]
    pub message_id: ::prost::alloc::vec::Vec<MessageIdData>,
    #[prost(enumeration = "command_ack::ValidationError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validation_error: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "5")]
    pub properties: ::prost::alloc::vec::Vec<KeyLongValue>,
    #[prost(uint64, optional, tag = "6", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_id: ::core::option::Option<u64>,
}
/// Nested message and enum types in `CommandAck`.
pub mod command_ack {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AckType {
        Individual = 0,
        Cumulative = 1,
    }
    impl AckType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AckType::Individual => "Individual",
                AckType::Cumulative => "Cumulative",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Individual" => Some(Self::Individual),
                "Cumulative" => Some(Self::Cumulative),
                _ => None,
            }
        }
    }
    /// Acks can contain a flag to indicate the consumer
    /// received an invalid message that got discarded
    /// before being passed on to the application.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValidationError {
        UncompressedSizeCorruption = 0,
        DecompressionError = 1,
        ChecksumMismatch = 2,
        BatchDeSerializeError = 3,
        DecryptionError = 4,
    }
    impl ValidationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValidationError::UncompressedSizeCorruption => {
                    "UncompressedSizeCorruption"
                }
                ValidationError::DecompressionError => "DecompressionError",
                ValidationError::ChecksumMismatch => "ChecksumMismatch",
                ValidationError::BatchDeSerializeError => "BatchDeSerializeError",
                ValidationError::DecryptionError => "DecryptionError",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UncompressedSizeCorruption" => Some(Self::UncompressedSizeCorruption),
                "DecompressionError" => Some(Self::DecompressionError),
                "ChecksumMismatch" => Some(Self::ChecksumMismatch),
                "BatchDeSerializeError" => Some(Self::BatchDeSerializeError),
                "DecryptionError" => Some(Self::DecryptionError),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAckResponse {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_id: ::core::option::Option<u64>,
}
/// changes on active consumer
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandActiveConsumerChange {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(bool, optional, tag = "2", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_active: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandFlow {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    /// Max number of messages to prefetch, in addition
    /// of any number previously specified
    #[prost(uint32, required, tag = "2")]
    pub message_permits: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandUnsubscribe {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(bool, optional, tag = "3", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: ::core::option::Option<bool>,
}
/// Reset an existing consumer to a particular message id
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSeek {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(message, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: ::core::option::Option<MessageIdData>,
    #[prost(uint64, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_publish_time: ::core::option::Option<u64>,
}
/// Message sent by broker to client when a topic
/// has been forcefully terminated and there are no more
/// messages left to consume
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandReachedEndOfTopic {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandTopicMigrated {
    #[prost(uint64, required, tag = "1")]
    pub resource_id: u64,
    #[prost(enumeration = "command_topic_migrated::ResourceType", required, tag = "2")]
    pub resource_type: i32,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub broker_service_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub broker_service_url_tls: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CommandTopicMigrated`.
pub mod command_topic_migrated {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceType {
        Producer = 0,
        Consumer = 1,
    }
    impl ResourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResourceType::Producer => "Producer",
                ResourceType::Consumer => "Consumer",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Producer" => Some(Self::Producer),
                "Consumer" => Some(Self::Consumer),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandCloseProducer {
    #[prost(uint64, required, tag = "1")]
    pub producer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_broker_service_url: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_broker_service_url_tls: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandCloseConsumer {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_broker_service_url: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_broker_service_url_tls: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandRedeliverUnacknowledgedMessages {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(message, repeated, tag = "2")]
    pub message_ids: ::prost::alloc::vec::Vec<MessageIdData>,
    #[prost(uint64, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_epoch: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandSuccess {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(message, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: ::core::option::Option<Schema>,
}
/// / Response from CommandProducer
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandProducerSuccess {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(string, required, tag = "2")]
    pub producer_name: ::prost::alloc::string::String,
    /// The last sequence id that was stored by this producer in the previous session
    /// This will only be meaningful if deduplication has been enabled.
    #[prost(int64, optional, tag = "3", default = "-1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_sequence_id: ::core::option::Option<i64>,
    #[prost(bytes = "vec", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The topic epoch assigned by the broker. This field will only be set if we
    /// were requiring exclusive access when creating the producer.
    #[prost(uint64, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_epoch: ::core::option::Option<u64>,
    /// If producer is not "ready", the client will avoid to timeout the request
    /// for creating the producer. Instead it will wait indefinitely until it gets
    /// a subsequent  `CommandProducerSuccess` with `producer_ready==true`.
    #[prost(bool, optional, tag = "6", default = "true")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub producer_ready: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandError {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(enumeration = "ServerError", required, tag = "2")]
    pub error: i32,
    #[prost(string, required, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Commands to probe the state of connection.
/// When either client or broker doesn't receive commands for certain
/// amount of time, they will send a Ping probe.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandPing {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandPong {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandConsumerStats {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    /// required string topic_name         = 2;
    /// required string subscription_name  = 3;
    #[prost(uint64, required, tag = "4")]
    pub consumer_id: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandConsumerStatsResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(enumeration = "ServerError", optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// / Total rate of messages delivered to the consumer. msg/s
    #[prost(double, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msg_rate_out: ::core::option::Option<f64>,
    /// / Total throughput delivered to the consumer. bytes/s
    #[prost(double, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msg_throughput_out: ::core::option::Option<f64>,
    /// / Total rate of messages redelivered by this consumer. msg/s
    #[prost(double, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msg_rate_redeliver: ::core::option::Option<f64>,
    /// / Name of the consumer
    #[prost(string, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// / Number of available message permits for the consumer
    #[prost(uint64, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub available_permits: ::core::option::Option<u64>,
    /// / Number of unacknowledged messages for the consumer
    #[prost(uint64, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unacked_messages: ::core::option::Option<u64>,
    /// / Flag to verify if consumer is blocked due to reaching threshold of unacked messages
    #[prost(bool, optional, tag = "10")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blocked_consumer_on_unacked_msgs: ::core::option::Option<bool>,
    /// / Address of this consumer
    #[prost(string, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// / Timestamp of connection
    #[prost(string, optional, tag = "12")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connected_since: ::core::option::Option<::prost::alloc::string::String>,
    /// / Whether this subscription is Exclusive or Shared or Failover
    #[prost(string, optional, tag = "13")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// / Total rate of messages expired on this subscription. msg/s
    #[prost(double, optional, tag = "14")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msg_rate_expired: ::core::option::Option<f64>,
    /// / Number of messages in the subscription backlog
    #[prost(uint64, optional, tag = "15")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msg_backlog: ::core::option::Option<u64>,
    /// / Total rate of messages ack. msg/s
    #[prost(double, optional, tag = "16")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_ack_rate: ::core::option::Option<f64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetLastMessageId {
    #[prost(uint64, required, tag = "1")]
    pub consumer_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetLastMessageIdResponse {
    #[prost(message, required, tag = "1")]
    pub last_message_id: MessageIdData,
    #[prost(uint64, required, tag = "2")]
    pub request_id: u64,
    #[prost(message, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_mark_delete_position: ::core::option::Option<MessageIdData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetTopicsOfNamespace {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(string, required, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(
        enumeration = "command_get_topics_of_namespace::Mode",
        optional,
        tag = "3",
        default = "Persistent"
    )]
    pub mode: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topics_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topics_hash: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CommandGetTopicsOfNamespace`.
pub mod command_get_topics_of_namespace {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Persistent = 0,
        NonPersistent = 1,
        All = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::Persistent => "PERSISTENT",
                Mode::NonPersistent => "NON_PERSISTENT",
                Mode::All => "ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERSISTENT" => Some(Self::Persistent),
                "NON_PERSISTENT" => Some(Self::NonPersistent),
                "ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetTopicsOfNamespaceResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(string, repeated, tag = "2")]
    pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// true iff the topic list was filtered by the pattern supplied by the client
    #[prost(bool, optional, tag = "3", default = "false")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filtered: ::core::option::Option<bool>,
    /// hash computed from the names of matching topics
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topics_hash: ::core::option::Option<::prost::alloc::string::String>,
    /// if false, topics is empty and the list of matching topics has not changed
    #[prost(bool, optional, tag = "5", default = "true")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub changed: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandWatchTopicList {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub watcher_id: u64,
    #[prost(string, required, tag = "3")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub topics_pattern: ::prost::alloc::string::String,
    /// Only present when the client reconnects:
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topics_hash: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandWatchTopicListSuccess {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub watcher_id: u64,
    #[prost(string, repeated, tag = "3")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, required, tag = "4")]
    pub topics_hash: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandWatchTopicUpdate {
    #[prost(uint64, required, tag = "1")]
    pub watcher_id: u64,
    #[prost(string, repeated, tag = "2")]
    pub new_topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub deleted_topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, required, tag = "4")]
    pub topics_hash: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandWatchTopicListClose {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, required, tag = "2")]
    pub watcher_id: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetSchema {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(string, required, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(bytes = "vec", optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetSchemaResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(enumeration = "ServerError", optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: ::core::option::Option<Schema>,
    #[prost(bytes = "vec", optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetOrCreateSchema {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(string, required, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, required, tag = "3")]
    pub schema: Schema,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandGetOrCreateSchemaResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(enumeration = "ServerError", optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandTcClientConnectRequest {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, required, tag = "2", default = "0")]
    pub tc_id: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandTcClientConnectResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(enumeration = "ServerError", optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandNewTxn {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txn_ttl_seconds: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tc_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandNewTxnResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAddPartitionToTxn {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(string, repeated, tag = "4")]
    pub partitions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAddPartitionToTxnResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    #[prost(string, required, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub subscription: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAddSubscriptionToTxn {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "4")]
    pub subscription: ::prost::alloc::vec::Vec<Subscription>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandAddSubscriptionToTxnResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEndTxn {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "TxnAction", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txn_action: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEndTxnResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEndTxnOnPartition {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "TxnAction", optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txn_action: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits_of_low_watermark: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEndTxnOnPartitionResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEndTxnOnSubscription {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscription: ::core::option::Option<Subscription>,
    #[prost(enumeration = "TxnAction", optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txn_action: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits_of_low_watermark: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandEndTxnOnSubscriptionResponse {
    #[prost(uint64, required, tag = "1")]
    pub request_id: u64,
    #[prost(uint64, optional, tag = "2", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_least_bits: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3", default = "0")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub txnid_most_bits: ::core::option::Option<u64>,
    #[prost(enumeration = "ServerError", optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BaseCommand {
    #[prost(enumeration = "base_command::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connect: ::core::option::Option<CommandConnect>,
    #[prost(message, optional, tag = "3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connected: ::core::option::Option<CommandConnected>,
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribe: ::core::option::Option<CommandSubscribe>,
    #[prost(message, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub producer: ::core::option::Option<CommandProducer>,
    #[prost(message, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send: ::core::option::Option<CommandSend>,
    #[prost(message, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send_receipt: ::core::option::Option<CommandSendReceipt>,
    #[prost(message, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send_error: ::core::option::Option<CommandSendError>,
    #[prost(message, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: ::core::option::Option<CommandMessage>,
    #[prost(message, optional, tag = "10")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ack: ::core::option::Option<CommandAck>,
    #[prost(message, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flow: ::core::option::Option<CommandFlow>,
    #[prost(message, optional, tag = "12")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unsubscribe: ::core::option::Option<CommandUnsubscribe>,
    #[prost(message, optional, tag = "13")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success: ::core::option::Option<CommandSuccess>,
    #[prost(message, optional, tag = "14")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: ::core::option::Option<CommandError>,
    #[prost(message, optional, tag = "15")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub close_producer: ::core::option::Option<CommandCloseProducer>,
    #[prost(message, optional, tag = "16")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub close_consumer: ::core::option::Option<CommandCloseConsumer>,
    #[prost(message, optional, tag = "17")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub producer_success: ::core::option::Option<CommandProducerSuccess>,
    #[prost(message, optional, tag = "18")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ping: ::core::option::Option<CommandPing>,
    #[prost(message, optional, tag = "19")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pong: ::core::option::Option<CommandPong>,
    #[prost(message, optional, tag = "20")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redeliver_unacknowledged_messages: ::core::option::Option<
        CommandRedeliverUnacknowledgedMessages,
    >,
    #[prost(message, optional, tag = "21")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_metadata: ::core::option::Option<CommandPartitionedTopicMetadata>,
    #[prost(message, optional, tag = "22")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_metadata_response: ::core::option::Option<
        CommandPartitionedTopicMetadataResponse,
    >,
    #[prost(message, optional, tag = "23")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lookup_topic: ::core::option::Option<CommandLookupTopic>,
    #[prost(message, optional, tag = "24")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lookup_topic_response: ::core::option::Option<CommandLookupTopicResponse>,
    #[prost(message, optional, tag = "25")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_stats: ::core::option::Option<CommandConsumerStats>,
    #[prost(message, optional, tag = "26")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_stats_response: ::core::option::Option<CommandConsumerStatsResponse>,
    #[prost(message, optional, tag = "27")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reached_end_of_topic: ::core::option::Option<CommandReachedEndOfTopic>,
    #[prost(message, optional, tag = "28")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seek: ::core::option::Option<CommandSeek>,
    #[prost(message, optional, tag = "29")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_last_message_id: ::core::option::Option<CommandGetLastMessageId>,
    #[prost(message, optional, tag = "30")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_last_message_id_response: ::core::option::Option<
        CommandGetLastMessageIdResponse,
    >,
    #[prost(message, optional, tag = "31")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active_consumer_change: ::core::option::Option<CommandActiveConsumerChange>,
    #[prost(message, optional, tag = "32")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_topics_of_namespace: ::core::option::Option<CommandGetTopicsOfNamespace>,
    #[prost(message, optional, tag = "33")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_topics_of_namespace_response: ::core::option::Option<
        CommandGetTopicsOfNamespaceResponse,
    >,
    #[prost(message, optional, tag = "34")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_schema: ::core::option::Option<CommandGetSchema>,
    #[prost(message, optional, tag = "35")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_schema_response: ::core::option::Option<CommandGetSchemaResponse>,
    #[prost(message, optional, tag = "36")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_challenge: ::core::option::Option<CommandAuthChallenge>,
    #[prost(message, optional, tag = "37")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_response: ::core::option::Option<CommandAuthResponse>,
    #[prost(message, optional, tag = "38")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ack_response: ::core::option::Option<CommandAckResponse>,
    #[prost(message, optional, tag = "39")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_or_create_schema: ::core::option::Option<CommandGetOrCreateSchema>,
    #[prost(message, optional, tag = "40")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub get_or_create_schema_response: ::core::option::Option<
        CommandGetOrCreateSchemaResponse,
    >,
    /// transaction related
    #[prost(message, optional, tag = "50")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_txn: ::core::option::Option<CommandNewTxn>,
    #[prost(message, optional, tag = "51")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_txn_response: ::core::option::Option<CommandNewTxnResponse>,
    #[prost(message, optional, tag = "52")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_partition_to_txn: ::core::option::Option<CommandAddPartitionToTxn>,
    #[prost(message, optional, tag = "53")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_partition_to_txn_response: ::core::option::Option<
        CommandAddPartitionToTxnResponse,
    >,
    #[prost(message, optional, tag = "54")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_subscription_to_txn: ::core::option::Option<CommandAddSubscriptionToTxn>,
    #[prost(message, optional, tag = "55")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_subscription_to_txn_response: ::core::option::Option<
        CommandAddSubscriptionToTxnResponse,
    >,
    #[prost(message, optional, tag = "56")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_txn: ::core::option::Option<CommandEndTxn>,
    #[prost(message, optional, tag = "57")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_txn_response: ::core::option::Option<CommandEndTxnResponse>,
    #[prost(message, optional, tag = "58")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_txn_on_partition: ::core::option::Option<CommandEndTxnOnPartition>,
    #[prost(message, optional, tag = "59")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_txn_on_partition_response: ::core::option::Option<
        CommandEndTxnOnPartitionResponse,
    >,
    #[prost(message, optional, tag = "60")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_txn_on_subscription: ::core::option::Option<CommandEndTxnOnSubscription>,
    #[prost(message, optional, tag = "61")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_txn_on_subscription_response: ::core::option::Option<
        CommandEndTxnOnSubscriptionResponse,
    >,
    #[prost(message, optional, tag = "62")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tc_client_connect_request: ::core::option::Option<CommandTcClientConnectRequest>,
    #[prost(message, optional, tag = "63")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tc_client_connect_response: ::core::option::Option<
        CommandTcClientConnectResponse,
    >,
    #[prost(message, optional, tag = "64")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub watch_topic_list: ::core::option::Option<CommandWatchTopicList>,
    #[prost(message, optional, tag = "65")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub watch_topic_list_success: ::core::option::Option<CommandWatchTopicListSuccess>,
    #[prost(message, optional, tag = "66")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub watch_topic_update: ::core::option::Option<CommandWatchTopicUpdate>,
    #[prost(message, optional, tag = "67")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub watch_topic_list_close: ::core::option::Option<CommandWatchTopicListClose>,
    #[prost(message, optional, tag = "68")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_migrated: ::core::option::Option<CommandTopicMigrated>,
}
/// Nested message and enum types in `BaseCommand`.
pub mod base_command {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Connect = 2,
        Connected = 3,
        Subscribe = 4,
        Producer = 5,
        Send = 6,
        SendReceipt = 7,
        SendError = 8,
        Message = 9,
        Ack = 10,
        Flow = 11,
        Unsubscribe = 12,
        Success = 13,
        Error = 14,
        CloseProducer = 15,
        CloseConsumer = 16,
        ProducerSuccess = 17,
        Ping = 18,
        Pong = 19,
        RedeliverUnacknowledgedMessages = 20,
        PartitionedMetadata = 21,
        PartitionedMetadataResponse = 22,
        Lookup = 23,
        LookupResponse = 24,
        ConsumerStats = 25,
        ConsumerStatsResponse = 26,
        ReachedEndOfTopic = 27,
        Seek = 28,
        GetLastMessageId = 29,
        GetLastMessageIdResponse = 30,
        ActiveConsumerChange = 31,
        GetTopicsOfNamespace = 32,
        GetTopicsOfNamespaceResponse = 33,
        GetSchema = 34,
        GetSchemaResponse = 35,
        AuthChallenge = 36,
        AuthResponse = 37,
        AckResponse = 38,
        GetOrCreateSchema = 39,
        GetOrCreateSchemaResponse = 40,
        /// transaction related
        NewTxn = 50,
        NewTxnResponse = 51,
        AddPartitionToTxn = 52,
        AddPartitionToTxnResponse = 53,
        AddSubscriptionToTxn = 54,
        AddSubscriptionToTxnResponse = 55,
        EndTxn = 56,
        EndTxnResponse = 57,
        EndTxnOnPartition = 58,
        EndTxnOnPartitionResponse = 59,
        EndTxnOnSubscription = 60,
        EndTxnOnSubscriptionResponse = 61,
        TcClientConnectRequest = 62,
        TcClientConnectResponse = 63,
        WatchTopicList = 64,
        WatchTopicListSuccess = 65,
        WatchTopicUpdate = 66,
        WatchTopicListClose = 67,
        TopicMigrated = 68,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Connect => "CONNECT",
                Type::Connected => "CONNECTED",
                Type::Subscribe => "SUBSCRIBE",
                Type::Producer => "PRODUCER",
                Type::Send => "SEND",
                Type::SendReceipt => "SEND_RECEIPT",
                Type::SendError => "SEND_ERROR",
                Type::Message => "MESSAGE",
                Type::Ack => "ACK",
                Type::Flow => "FLOW",
                Type::Unsubscribe => "UNSUBSCRIBE",
                Type::Success => "SUCCESS",
                Type::Error => "ERROR",
                Type::CloseProducer => "CLOSE_PRODUCER",
                Type::CloseConsumer => "CLOSE_CONSUMER",
                Type::ProducerSuccess => "PRODUCER_SUCCESS",
                Type::Ping => "PING",
                Type::Pong => "PONG",
                Type::RedeliverUnacknowledgedMessages => {
                    "REDELIVER_UNACKNOWLEDGED_MESSAGES"
                }
                Type::PartitionedMetadata => "PARTITIONED_METADATA",
                Type::PartitionedMetadataResponse => "PARTITIONED_METADATA_RESPONSE",
                Type::Lookup => "LOOKUP",
                Type::LookupResponse => "LOOKUP_RESPONSE",
                Type::ConsumerStats => "CONSUMER_STATS",
                Type::ConsumerStatsResponse => "CONSUMER_STATS_RESPONSE",
                Type::ReachedEndOfTopic => "REACHED_END_OF_TOPIC",
                Type::Seek => "SEEK",
                Type::GetLastMessageId => "GET_LAST_MESSAGE_ID",
                Type::GetLastMessageIdResponse => "GET_LAST_MESSAGE_ID_RESPONSE",
                Type::ActiveConsumerChange => "ACTIVE_CONSUMER_CHANGE",
                Type::GetTopicsOfNamespace => "GET_TOPICS_OF_NAMESPACE",
                Type::GetTopicsOfNamespaceResponse => "GET_TOPICS_OF_NAMESPACE_RESPONSE",
                Type::GetSchema => "GET_SCHEMA",
                Type::GetSchemaResponse => "GET_SCHEMA_RESPONSE",
                Type::AuthChallenge => "AUTH_CHALLENGE",
                Type::AuthResponse => "AUTH_RESPONSE",
                Type::AckResponse => "ACK_RESPONSE",
                Type::GetOrCreateSchema => "GET_OR_CREATE_SCHEMA",
                Type::GetOrCreateSchemaResponse => "GET_OR_CREATE_SCHEMA_RESPONSE",
                Type::NewTxn => "NEW_TXN",
                Type::NewTxnResponse => "NEW_TXN_RESPONSE",
                Type::AddPartitionToTxn => "ADD_PARTITION_TO_TXN",
                Type::AddPartitionToTxnResponse => "ADD_PARTITION_TO_TXN_RESPONSE",
                Type::AddSubscriptionToTxn => "ADD_SUBSCRIPTION_TO_TXN",
                Type::AddSubscriptionToTxnResponse => "ADD_SUBSCRIPTION_TO_TXN_RESPONSE",
                Type::EndTxn => "END_TXN",
                Type::EndTxnResponse => "END_TXN_RESPONSE",
                Type::EndTxnOnPartition => "END_TXN_ON_PARTITION",
                Type::EndTxnOnPartitionResponse => "END_TXN_ON_PARTITION_RESPONSE",
                Type::EndTxnOnSubscription => "END_TXN_ON_SUBSCRIPTION",
                Type::EndTxnOnSubscriptionResponse => "END_TXN_ON_SUBSCRIPTION_RESPONSE",
                Type::TcClientConnectRequest => "TC_CLIENT_CONNECT_REQUEST",
                Type::TcClientConnectResponse => "TC_CLIENT_CONNECT_RESPONSE",
                Type::WatchTopicList => "WATCH_TOPIC_LIST",
                Type::WatchTopicListSuccess => "WATCH_TOPIC_LIST_SUCCESS",
                Type::WatchTopicUpdate => "WATCH_TOPIC_UPDATE",
                Type::WatchTopicListClose => "WATCH_TOPIC_LIST_CLOSE",
                Type::TopicMigrated => "TOPIC_MIGRATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECT" => Some(Self::Connect),
                "CONNECTED" => Some(Self::Connected),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "PRODUCER" => Some(Self::Producer),
                "SEND" => Some(Self::Send),
                "SEND_RECEIPT" => Some(Self::SendReceipt),
                "SEND_ERROR" => Some(Self::SendError),
                "MESSAGE" => Some(Self::Message),
                "ACK" => Some(Self::Ack),
                "FLOW" => Some(Self::Flow),
                "UNSUBSCRIBE" => Some(Self::Unsubscribe),
                "SUCCESS" => Some(Self::Success),
                "ERROR" => Some(Self::Error),
                "CLOSE_PRODUCER" => Some(Self::CloseProducer),
                "CLOSE_CONSUMER" => Some(Self::CloseConsumer),
                "PRODUCER_SUCCESS" => Some(Self::ProducerSuccess),
                "PING" => Some(Self::Ping),
                "PONG" => Some(Self::Pong),
                "REDELIVER_UNACKNOWLEDGED_MESSAGES" => {
                    Some(Self::RedeliverUnacknowledgedMessages)
                }
                "PARTITIONED_METADATA" => Some(Self::PartitionedMetadata),
                "PARTITIONED_METADATA_RESPONSE" => {
                    Some(Self::PartitionedMetadataResponse)
                }
                "LOOKUP" => Some(Self::Lookup),
                "LOOKUP_RESPONSE" => Some(Self::LookupResponse),
                "CONSUMER_STATS" => Some(Self::ConsumerStats),
                "CONSUMER_STATS_RESPONSE" => Some(Self::ConsumerStatsResponse),
                "REACHED_END_OF_TOPIC" => Some(Self::ReachedEndOfTopic),
                "SEEK" => Some(Self::Seek),
                "GET_LAST_MESSAGE_ID" => Some(Self::GetLastMessageId),
                "GET_LAST_MESSAGE_ID_RESPONSE" => Some(Self::GetLastMessageIdResponse),
                "ACTIVE_CONSUMER_CHANGE" => Some(Self::ActiveConsumerChange),
                "GET_TOPICS_OF_NAMESPACE" => Some(Self::GetTopicsOfNamespace),
                "GET_TOPICS_OF_NAMESPACE_RESPONSE" => {
                    Some(Self::GetTopicsOfNamespaceResponse)
                }
                "GET_SCHEMA" => Some(Self::GetSchema),
                "GET_SCHEMA_RESPONSE" => Some(Self::GetSchemaResponse),
                "AUTH_CHALLENGE" => Some(Self::AuthChallenge),
                "AUTH_RESPONSE" => Some(Self::AuthResponse),
                "ACK_RESPONSE" => Some(Self::AckResponse),
                "GET_OR_CREATE_SCHEMA" => Some(Self::GetOrCreateSchema),
                "GET_OR_CREATE_SCHEMA_RESPONSE" => Some(Self::GetOrCreateSchemaResponse),
                "NEW_TXN" => Some(Self::NewTxn),
                "NEW_TXN_RESPONSE" => Some(Self::NewTxnResponse),
                "ADD_PARTITION_TO_TXN" => Some(Self::AddPartitionToTxn),
                "ADD_PARTITION_TO_TXN_RESPONSE" => Some(Self::AddPartitionToTxnResponse),
                "ADD_SUBSCRIPTION_TO_TXN" => Some(Self::AddSubscriptionToTxn),
                "ADD_SUBSCRIPTION_TO_TXN_RESPONSE" => {
                    Some(Self::AddSubscriptionToTxnResponse)
                }
                "END_TXN" => Some(Self::EndTxn),
                "END_TXN_RESPONSE" => Some(Self::EndTxnResponse),
                "END_TXN_ON_PARTITION" => Some(Self::EndTxnOnPartition),
                "END_TXN_ON_PARTITION_RESPONSE" => Some(Self::EndTxnOnPartitionResponse),
                "END_TXN_ON_SUBSCRIPTION" => Some(Self::EndTxnOnSubscription),
                "END_TXN_ON_SUBSCRIPTION_RESPONSE" => {
                    Some(Self::EndTxnOnSubscriptionResponse)
                }
                "TC_CLIENT_CONNECT_REQUEST" => Some(Self::TcClientConnectRequest),
                "TC_CLIENT_CONNECT_RESPONSE" => Some(Self::TcClientConnectResponse),
                "WATCH_TOPIC_LIST" => Some(Self::WatchTopicList),
                "WATCH_TOPIC_LIST_SUCCESS" => Some(Self::WatchTopicListSuccess),
                "WATCH_TOPIC_UPDATE" => Some(Self::WatchTopicUpdate),
                "WATCH_TOPIC_LIST_CLOSE" => Some(Self::WatchTopicListClose),
                "TOPIC_MIGRATED" => Some(Self::TopicMigrated),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionType {
    None = 0,
    Lz4 = 1,
    Zlib = 2,
    Zstd = 3,
    Snappy = 4,
}
impl CompressionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompressionType::None => "NONE",
            CompressionType::Lz4 => "LZ4",
            CompressionType::Zlib => "ZLIB",
            CompressionType::Zstd => "ZSTD",
            CompressionType::Snappy => "SNAPPY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "LZ4" => Some(Self::Lz4),
            "ZLIB" => Some(Self::Zlib),
            "ZSTD" => Some(Self::Zstd),
            "SNAPPY" => Some(Self::Snappy),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProducerAccessMode {
    /// By default multiple producers can publish on a topic
    Shared = 0,
    /// Require exclusive access for producer. Fail immediately if there's already a producer connected.
    Exclusive = 1,
    /// Producer creation is pending until it can acquire exclusive access
    WaitForExclusive = 2,
    /// Require exclusive access for producer. Fence out old producer.
    ExclusiveWithFencing = 3,
}
impl ProducerAccessMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProducerAccessMode::Shared => "Shared",
            ProducerAccessMode::Exclusive => "Exclusive",
            ProducerAccessMode::WaitForExclusive => "WaitForExclusive",
            ProducerAccessMode::ExclusiveWithFencing => "ExclusiveWithFencing",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Shared" => Some(Self::Shared),
            "Exclusive" => Some(Self::Exclusive),
            "WaitForExclusive" => Some(Self::WaitForExclusive),
            "ExclusiveWithFencing" => Some(Self::ExclusiveWithFencing),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServerError {
    UnknownError = 0,
    /// Error with ZK/metadata
    MetadataError = 1,
    /// Error writing reading from BK
    PersistenceError = 2,
    /// Non valid authentication
    AuthenticationError = 3,
    /// Not authorized to use resource
    AuthorizationError = 4,
    /// Unable to subscribe/unsubscribe because
    ConsumerBusy = 5,
    /// other consumers are connected
    ///
    /// Any error that requires client retry operation with a fresh lookup
    ServiceNotReady = 6,
    /// Unable to create producer because backlog quota exceeded
    ProducerBlockedQuotaExceededError = 7,
    /// Exception while creating producer because quota exceeded
    ProducerBlockedQuotaExceededException = 8,
    /// Error while verifying message checksum
    ChecksumError = 9,
    /// Error when an older client/version doesn't support a required feature
    UnsupportedVersionError = 10,
    /// Topic not found
    TopicNotFound = 11,
    /// Subscription not found
    SubscriptionNotFound = 12,
    /// Consumer not found
    ConsumerNotFound = 13,
    /// Error with too many simultaneously request
    TooManyRequests = 14,
    /// The topic has been terminated
    TopicTerminatedError = 15,
    /// Producer with same name is already connected
    ProducerBusy = 16,
    /// The topic name is not valid
    InvalidTopicName = 17,
    /// Specified schema was incompatible with topic schema
    IncompatibleSchema = 18,
    /// Dispatcher assign consumer error
    ConsumerAssignError = 19,
    /// Transaction coordinator not found error
    TransactionCoordinatorNotFound = 20,
    /// Invalid txn status error
    InvalidTxnStatus = 21,
    /// Not allowed error
    NotAllowedError = 22,
    /// Ack with transaction conflict
    TransactionConflict = 23,
    /// Transaction not found
    TransactionNotFound = 24,
    /// When a producer asks and fail to get exclusive producer access,
    ProducerFenced = 25,
}
impl ServerError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ServerError::UnknownError => "UnknownError",
            ServerError::MetadataError => "MetadataError",
            ServerError::PersistenceError => "PersistenceError",
            ServerError::AuthenticationError => "AuthenticationError",
            ServerError::AuthorizationError => "AuthorizationError",
            ServerError::ConsumerBusy => "ConsumerBusy",
            ServerError::ServiceNotReady => "ServiceNotReady",
            ServerError::ProducerBlockedQuotaExceededError => {
                "ProducerBlockedQuotaExceededError"
            }
            ServerError::ProducerBlockedQuotaExceededException => {
                "ProducerBlockedQuotaExceededException"
            }
            ServerError::ChecksumError => "ChecksumError",
            ServerError::UnsupportedVersionError => "UnsupportedVersionError",
            ServerError::TopicNotFound => "TopicNotFound",
            ServerError::SubscriptionNotFound => "SubscriptionNotFound",
            ServerError::ConsumerNotFound => "ConsumerNotFound",
            ServerError::TooManyRequests => "TooManyRequests",
            ServerError::TopicTerminatedError => "TopicTerminatedError",
            ServerError::ProducerBusy => "ProducerBusy",
            ServerError::InvalidTopicName => "InvalidTopicName",
            ServerError::IncompatibleSchema => "IncompatibleSchema",
            ServerError::ConsumerAssignError => "ConsumerAssignError",
            ServerError::TransactionCoordinatorNotFound => {
                "TransactionCoordinatorNotFound"
            }
            ServerError::InvalidTxnStatus => "InvalidTxnStatus",
            ServerError::NotAllowedError => "NotAllowedError",
            ServerError::TransactionConflict => "TransactionConflict",
            ServerError::TransactionNotFound => "TransactionNotFound",
            ServerError::ProducerFenced => "ProducerFenced",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownError" => Some(Self::UnknownError),
            "MetadataError" => Some(Self::MetadataError),
            "PersistenceError" => Some(Self::PersistenceError),
            "AuthenticationError" => Some(Self::AuthenticationError),
            "AuthorizationError" => Some(Self::AuthorizationError),
            "ConsumerBusy" => Some(Self::ConsumerBusy),
            "ServiceNotReady" => Some(Self::ServiceNotReady),
            "ProducerBlockedQuotaExceededError" => {
                Some(Self::ProducerBlockedQuotaExceededError)
            }
            "ProducerBlockedQuotaExceededException" => {
                Some(Self::ProducerBlockedQuotaExceededException)
            }
            "ChecksumError" => Some(Self::ChecksumError),
            "UnsupportedVersionError" => Some(Self::UnsupportedVersionError),
            "TopicNotFound" => Some(Self::TopicNotFound),
            "SubscriptionNotFound" => Some(Self::SubscriptionNotFound),
            "ConsumerNotFound" => Some(Self::ConsumerNotFound),
            "TooManyRequests" => Some(Self::TooManyRequests),
            "TopicTerminatedError" => Some(Self::TopicTerminatedError),
            "ProducerBusy" => Some(Self::ProducerBusy),
            "InvalidTopicName" => Some(Self::InvalidTopicName),
            "IncompatibleSchema" => Some(Self::IncompatibleSchema),
            "ConsumerAssignError" => Some(Self::ConsumerAssignError),
            "TransactionCoordinatorNotFound" => {
                Some(Self::TransactionCoordinatorNotFound)
            }
            "InvalidTxnStatus" => Some(Self::InvalidTxnStatus),
            "NotAllowedError" => Some(Self::NotAllowedError),
            "TransactionConflict" => Some(Self::TransactionConflict),
            "TransactionNotFound" => Some(Self::TransactionNotFound),
            "ProducerFenced" => Some(Self::ProducerFenced),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthMethod {
    None = 0,
    YcaV1 = 1,
    Athens = 2,
}
impl AuthMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuthMethod::None => "AuthMethodNone",
            AuthMethod::YcaV1 => "AuthMethodYcaV1",
            AuthMethod::Athens => "AuthMethodAthens",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AuthMethodNone" => Some(Self::None),
            "AuthMethodYcaV1" => Some(Self::YcaV1),
            "AuthMethodAthens" => Some(Self::Athens),
            _ => None,
        }
    }
}
/// Each protocol version identify new features that are
/// incrementally added to the protocol
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolVersion {
    /// Initial versioning
    V0 = 0,
    /// Added application keep-alive
    V1 = 1,
    /// Added RedeliverUnacknowledgedMessages Command
    V2 = 2,
    /// Added compression with LZ4 and ZLib
    V3 = 3,
    /// Added batch message support
    V4 = 4,
    /// Added disconnect client w/o closing connection
    V5 = 5,
    /// Added checksum computation for metadata + payload
    V6 = 6,
    /// Added CommandLookupTopic - Binary Lookup
    V7 = 7,
    /// Added CommandConsumerStats - Client fetches broker side consumer stats
    V8 = 8,
    /// Added end of topic notification
    V9 = 9,
    /// Added proxy to broker
    V10 = 10,
    /// C++ consumers before this version are not correctly handling the checksum field
    V11 = 11,
    /// Added get topic's last messageId from broker
    V12 = 12,
    /// Added CommandActiveConsumerChange
    /// Added CommandGetTopicsOfNamespace
    ///
    /// Schema-registry : added avro schema format for json
    V13 = 13,
    /// Add CommandAuthChallenge and CommandAuthResponse for mutual auth
    V14 = 14,
    /// Added Key_Shared subscription
    ///
    /// Add CommandGetOrCreateSchema and CommandGetOrCreateSchemaResponse
    V15 = 15,
    /// Add support for broker entry metadata
    V16 = 16,
    /// Added support ack receipt
    V17 = 17,
    /// Add client support for broker entry metadata
    V18 = 18,
    /// Add CommandTcClientConnectRequest and CommandTcClientConnectResponse
    V19 = 19,
    /// Add client support for topic migration redirection CommandTopicMigrated
    V20 = 20,
    /// Carry the AUTO_CONSUME schema to the Broker after this version
    V21 = 21,
}
impl ProtocolVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProtocolVersion::V0 => "v0",
            ProtocolVersion::V1 => "v1",
            ProtocolVersion::V2 => "v2",
            ProtocolVersion::V3 => "v3",
            ProtocolVersion::V4 => "v4",
            ProtocolVersion::V5 => "v5",
            ProtocolVersion::V6 => "v6",
            ProtocolVersion::V7 => "v7",
            ProtocolVersion::V8 => "v8",
            ProtocolVersion::V9 => "v9",
            ProtocolVersion::V10 => "v10",
            ProtocolVersion::V11 => "v11",
            ProtocolVersion::V12 => "v12",
            ProtocolVersion::V13 => "v13",
            ProtocolVersion::V14 => "v14",
            ProtocolVersion::V15 => "v15",
            ProtocolVersion::V16 => "v16",
            ProtocolVersion::V17 => "v17",
            ProtocolVersion::V18 => "v18",
            ProtocolVersion::V19 => "v19",
            ProtocolVersion::V20 => "v20",
            ProtocolVersion::V21 => "v21",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "v0" => Some(Self::V0),
            "v1" => Some(Self::V1),
            "v2" => Some(Self::V2),
            "v3" => Some(Self::V3),
            "v4" => Some(Self::V4),
            "v5" => Some(Self::V5),
            "v6" => Some(Self::V6),
            "v7" => Some(Self::V7),
            "v8" => Some(Self::V8),
            "v9" => Some(Self::V9),
            "v10" => Some(Self::V10),
            "v11" => Some(Self::V11),
            "v12" => Some(Self::V12),
            "v13" => Some(Self::V13),
            "v14" => Some(Self::V14),
            "v15" => Some(Self::V15),
            "v16" => Some(Self::V16),
            "v17" => Some(Self::V17),
            "v18" => Some(Self::V18),
            "v19" => Some(Self::V19),
            "v20" => Some(Self::V20),
            "v21" => Some(Self::V21),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeySharedMode {
    AutoSplit = 0,
    Sticky = 1,
}
impl KeySharedMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KeySharedMode::AutoSplit => "AUTO_SPLIT",
            KeySharedMode::Sticky => "STICKY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTO_SPLIT" => Some(Self::AutoSplit),
            "STICKY" => Some(Self::Sticky),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TxnAction {
    Commit = 0,
    Abort = 1,
}
impl TxnAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TxnAction::Commit => "COMMIT",
            TxnAction::Abort => "ABORT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMIT" => Some(Self::Commit),
            "ABORT" => Some(Self::Abort),
            _ => None,
        }
    }
}